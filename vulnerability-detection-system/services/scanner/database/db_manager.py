"""
数据库管理模块
"""
import asyncpg
import logging
import json
from typing import Dict, List, Optional
import os
from datetime import datetime

logger = logging.getLogger(__name__)


class DatabaseManager:
    """数据库管理器"""

    def __init__(self):
        self.database_url = os.getenv("DATABASE_URL", "")
        self.pool: Optional[asyncpg.Pool] = None

    async def init_db(self):
        """初始化数据库连接池"""
        try:
            logger.info("初始化数据库连接池...")

            self.pool = await asyncpg.create_pool(
                self.database_url,
                min_size=5,
                max_size=20,
                command_timeout=60
            )

            # 创建表结构
            await self._create_tables()

            logger.info("数据库连接池初始化完成")

        except Exception as e:
            logger.error(f"初始化数据库失败: {str(e)}")
            raise

    async def close(self):
        """关闭数据库连接池"""
        if self.pool:
            await self.pool.close()
            logger.info("数据库连接池已关闭")

    async def _create_tables(self):
        """创建数据表"""
        async with self.pool.acquire() as conn:
            # 创建扫描任务表
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS scan_tasks (
                    scan_id VARCHAR(255) PRIMARY KEY,
                    target TEXT NOT NULL,
                    scan_type VARCHAR(50) NOT NULL,
                    status VARCHAR(50) NOT NULL,
                    priority VARCHAR(20) DEFAULT 'normal',
                    scheduled BOOLEAN DEFAULT FALSE,
                    options JSONB,
                    error TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    completed_at TIMESTAMP
                )
            """)

            # 创建扫描结果表
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS scan_results (
                    id SERIAL PRIMARY KEY,
                    scan_id VARCHAR(255) REFERENCES scan_tasks(scan_id),
                    results JSONB NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # 创建资产表
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS assets (
                    id SERIAL PRIMARY KEY,
                    ip VARCHAR(50) NOT NULL,
                    hostname VARCHAR(255),
                    mac_address VARCHAR(50),
                    os_info JSONB,
                    services JSONB,
                    open_ports INTEGER DEFAULT 0,
                    status VARCHAR(20) NOT NULL,
                    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(ip)
                )
            """)

            # 创建漏洞记录表
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id SERIAL PRIMARY KEY,
                    scan_id VARCHAR(255) REFERENCES scan_tasks(scan_id),
                    asset_id INTEGER REFERENCES assets(id),
                    cve_id VARCHAR(50),
                    title TEXT NOT NULL,
                    description TEXT,
                    severity VARCHAR(20) NOT NULL,
                    cvss_score FLOAT,
                    cvss_vector TEXT,
                    affected_component TEXT,
                    port INTEGER,
                    service VARCHAR(100),
                    recommendation TEXT,
                    references JSONB,
                    status VARCHAR(50) DEFAULT 'open',
                    discovered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    resolved_at TIMESTAMP
                )
            """)

            # 创建索引
            await conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_scan_tasks_status ON scan_tasks(status);
                CREATE INDEX IF NOT EXISTS idx_scan_tasks_created ON scan_tasks(created_at);
                CREATE INDEX IF NOT EXISTS idx_vulnerabilities_severity ON vulnerabilities(severity);
                CREATE INDEX IF NOT EXISTS idx_vulnerabilities_status ON vulnerabilities(status);
                CREATE INDEX IF NOT EXISTS idx_assets_ip ON assets(ip);
            """)

            logger.info("数据表创建完成")

    async def create_scan_task(self, scan_task: Dict) -> str:
        """创建扫描任务"""
        async with self.pool.acquire() as conn:
            scan_id = scan_task["scan_id"]

            await conn.execute("""
                INSERT INTO scan_tasks (
                    scan_id, target, scan_type, status, priority,
                    scheduled, options, created_at, updated_at
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            """,
                scan_id,
                scan_task["target"],
                scan_task["scan_type"],
                scan_task["status"],
                scan_task.get("priority", "normal"),
                scan_task.get("scheduled", False),
                json.dumps(scan_task.get("options", {})),
                datetime.fromisoformat(scan_task["created_at"]),
                datetime.fromisoformat(scan_task["created_at"])
            )

            return scan_id

    async def update_scan_task(self, scan_id: str, update_data: Dict):
        """更新扫描任务"""
        async with self.pool.acquire() as conn:
            set_clauses = []
            values = []
            param_count = 1

            for key, value in update_data.items():
                if key == "updated_at":
                    set_clauses.append(f"{key} = ${param_count}")
                    values.append(datetime.fromisoformat(value))
                elif key == "completed_at" and value:
                    set_clauses.append(f"{key} = ${param_count}")
                    values.append(datetime.fromisoformat(value))
                else:
                    set_clauses.append(f"{key} = ${param_count}")
                    values.append(value)
                param_count += 1

            values.append(scan_id)

            query = f"""
                UPDATE scan_tasks
                SET {', '.join(set_clauses)}
                WHERE scan_id = ${param_count}
            """

            await conn.execute(query, *values)

    async def get_scan_task(self, scan_id: str) -> Optional[Dict]:
        """获取扫描任务"""
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow("""
                SELECT * FROM scan_tasks WHERE scan_id = $1
            """, scan_id)

            if row:
                return dict(row)

            return None

    async def save_scan_results(self, scan_id: str, results: Dict):
        """保存扫描结果"""
        async with self.pool.acquire() as conn:
            await conn.execute("""
                INSERT INTO scan_results (scan_id, results)
                VALUES ($1, $2)
            """, scan_id, json.dumps(results))

            # 保存漏洞信息
            vulnerabilities = results.get("vulnerabilities", [])
            for vuln in vulnerabilities:
                await self._save_vulnerability(conn, scan_id, vuln)

    async def _save_vulnerability(self, conn, scan_id: str, vuln: Dict):
        """保存漏洞信息"""
        await conn.execute("""
            INSERT INTO vulnerabilities (
                scan_id, cve_id, title, description, severity,
                cvss_score, cvss_vector, affected_component,
                port, service, recommendation, references
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        """,
            scan_id,
            vuln.get("cve_id"),
            vuln.get("title", ""),
            vuln.get("description", ""),
            vuln.get("severity", "unknown"),
            vuln.get("cvss_score", 0.0),
            vuln.get("cvss_vector"),
            vuln.get("affected_component"),
            vuln.get("port"),
            vuln.get("service"),
            vuln.get("recommendation", ""),
            json.dumps(vuln.get("references", []))
        )

    async def get_scan_results(self, scan_id: str) -> Optional[Dict]:
        """获取扫描结果"""
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow("""
                SELECT results FROM scan_results
                WHERE scan_id = $1
                ORDER BY created_at DESC
                LIMIT 1
            """, scan_id)

            if row:
                return json.loads(row["results"])

            return None

    async def save_assets(self, assets: List[Dict]):
        """保存资产信息"""
        async with self.pool.acquire() as conn:
            for asset in assets:
                await conn.execute("""
                    INSERT INTO assets (
                        ip, hostname, mac_address, os_info,
                        services, open_ports, status, last_seen
                    )
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                    ON CONFLICT (ip) DO UPDATE SET
                        hostname = EXCLUDED.hostname,
                        mac_address = EXCLUDED.mac_address,
                        os_info = EXCLUDED.os_info,
                        services = EXCLUDED.services,
                        open_ports = EXCLUDED.open_ports,
                        status = EXCLUDED.status,
                        last_seen = EXCLUDED.last_seen
                """,
                    asset["ip"],
                    asset.get("hostname"),
                    asset.get("mac_address"),
                    json.dumps(asset.get("os", {})),
                    json.dumps(asset.get("services", [])),
                    asset.get("open_ports", 0),
                    asset["status"],
                    datetime.utcnow()
                )

    async def get_vulnerabilities_by_severity(self, severity: str) -> List[Dict]:
        """根据严重程度获取漏洞"""
        async with self.pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT * FROM vulnerabilities
                WHERE severity = $1 AND status = 'open'
                ORDER BY discovered_at DESC
            """, severity)

            return [dict(row) for row in rows]

    async def get_vulnerability_statistics(self) -> Dict:
        """获取漏洞统计信息"""
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow("""
                SELECT
                    COUNT(*) as total,
                    COUNT(*) FILTER (WHERE severity = 'critical') as critical,
                    COUNT(*) FILTER (WHERE severity = 'high') as high,
                    COUNT(*) FILTER (WHERE severity = 'medium') as medium,
                    COUNT(*) FILTER (WHERE severity = 'low') as low,
                    COUNT(*) FILTER (WHERE status = 'open') as open,
                    COUNT(*) FILTER (WHERE status = 'resolved') as resolved
                FROM vulnerabilities
            """)

            return dict(row)
