"""
扫描引擎核心模块
"""
import asyncio
import uuid
from datetime import datetime
from typing import Dict, List, Optional
import nmap
import logging
from concurrent.futures import ThreadPoolExecutor

from models.scan_models import ScanRequest, VulnerabilityInfo
from database.db_manager import DatabaseManager

logger = logging.getLogger(__name__)


class ScannerEngine:
    """扫描引擎"""

    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.nm = nmap.PortScanner()
        self.executor = ThreadPoolExecutor(max_workers=4)
        self.active_scans: Dict[str, dict] = {}

    async def create_scan_task(self, scan_request: ScanRequest) -> str:
        """
        创建扫描任务

        Args:
            scan_request: 扫描请求

        Returns:
            扫描任务ID
        """
        scan_id = str(uuid.uuid4())

        scan_task = {
            "scan_id": scan_id,
            "status": "pending",
            "created_at": datetime.utcnow().isoformat(),
            "target": scan_request.target,
            "scan_type": scan_request.scan_type,
            "options": scan_request.options
        }

        # 保存到数据库
        await self.db_manager.create_scan_task(scan_task)

        # 加入活动扫描列表
        self.active_scans[scan_id] = scan_task

        return scan_id

    async def execute_scan(self, scan_id: str, scan_request: ScanRequest):
        """
        执行扫描

        Args:
            scan_id: 扫描任务ID
            scan_request: 扫描请求
        """
        try:
            logger.info(f"开始执行扫描: {scan_id}")

            # 更新状态为运行中
            await self.update_scan_status(scan_id, "running")

            # 执行不同类型的扫描
            if scan_request.scan_type == "port_scan":
                results = await self.port_scan(scan_request.target, scan_request.options)
            elif scan_request.scan_type == "vulnerability_scan":
                results = await self.vulnerability_scan(scan_request.target, scan_request.options)
            elif scan_request.scan_type == "full_scan":
                results = await self.full_scan(scan_request.target, scan_request.options)
            else:
                raise ValueError(f"不支持的扫描类型: {scan_request.scan_type}")

            # 保存结果
            await self.save_scan_results(scan_id, results)

            # 更新状态为完成
            await self.update_scan_status(scan_id, "completed")

            logger.info(f"扫描完成: {scan_id}, 发现 {len(results.get('vulnerabilities', []))} 个漏洞")

        except Exception as e:
            logger.error(f"扫描执行失败: {scan_id}, 错误: {str(e)}")
            await self.update_scan_status(scan_id, "failed", str(e))

    async def port_scan(self, target: str, options: dict) -> dict:
        """
        端口扫描

        Args:
            target: 目标地址
            options: 扫描选项

        Returns:
            扫描结果
        """
        logger.info(f"执行端口扫描: {target}")

        # 在线程池中执行同步的nmap扫描
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            self.executor,
            self._nmap_scan,
            target,
            options.get("ports", "1-1000")
        )

        return self._parse_nmap_results(result)

    def _nmap_scan(self, target: str, ports: str):
        """同步nmap扫描"""
        self.nm.scan(hosts=target, ports=ports, arguments='-sV -O')
        return self.nm

    def _parse_nmap_results(self, nm) -> dict:
        """解析nmap扫描结果"""
        results = {
            "hosts": [],
            "open_ports": [],
            "services": [],
            "vulnerabilities": []
        }

        for host in nm.all_hosts():
            host_info = {
                "ip": host,
                "hostname": nm[host].hostname(),
                "state": nm[host].state(),
                "ports": []
            }

            # 解析端口信息
            for proto in nm[host].all_protocols():
                ports = nm[host][proto].keys()

                for port in ports:
                    port_info = nm[host][proto][port]

                    port_data = {
                        "port": port,
                        "protocol": proto,
                        "state": port_info['state'],
                        "service": port_info.get('name', ''),
                        "version": port_info.get('version', ''),
                        "product": port_info.get('product', '')
                    }

                    host_info["ports"].append(port_data)
                    results["open_ports"].append(port_data)

                    # 检查服务版本漏洞
                    if port_info.get('version'):
                        vuln = self._check_service_vulnerability(
                            port_info.get('product', ''),
                            port_info.get('version', '')
                        )
                        if vuln:
                            results["vulnerabilities"].extend(vuln)

            results["hosts"].append(host_info)

        return results

    def _check_service_vulnerability(self, product: str, version: str) -> List[dict]:
        """检查服务版本漏洞"""
        # 这里应该查询漏洞数据库
        # 简化版实现
        vulnerabilities = []

        # 示例：检查已知的危险服务版本
        dangerous_services = {
            "Apache": ["2.4.49", "2.4.50"],
            "OpenSSH": ["7.4"],
            "vsftpd": ["2.3.4"]
        }

        if product in dangerous_services:
            if version in dangerous_services[product]:
                vulnerabilities.append({
                    "product": product,
                    "version": version,
                    "severity": "high",
                    "cve_id": f"CVE-EXAMPLE-{product}",
                    "description": f"{product} {version} 存在已知漏洞"
                })

        return vulnerabilities

    async def vulnerability_scan(self, target: str, options: dict) -> dict:
        """
        漏洞扫描

        Args:
            target: 目标地址
            options: 扫描选项

        Returns:
            扫描结果
        """
        logger.info(f"执行漏洞扫描: {target}")

        # 首先进行端口扫描
        port_results = await self.port_scan(target, options)

        # 然后进行漏洞检测
        vulnerabilities = []

        for service in port_results.get("services", []):
            # 检查服务漏洞
            vulns = await self._detect_service_vulnerabilities(service)
            vulnerabilities.extend(vulns)

        # 检查配置漏洞
        config_vulns = await self._detect_configuration_issues(target, port_results)
        vulnerabilities.extend(config_vulns)

        port_results["vulnerabilities"] = vulnerabilities

        return port_results

    async def _detect_service_vulnerabilities(self, service: dict) -> List[dict]:
        """检测服务漏洞"""
        # 实际应该查询CVE数据库
        vulnerabilities = []

        # 示例检测逻辑
        if service.get("service") == "http" and "Apache" in service.get("product", ""):
            vulnerabilities.append({
                "type": "service_vulnerability",
                "service": service.get("service"),
                "port": service.get("port"),
                "severity": "medium",
                "title": "Apache Web Server 漏洞",
                "description": "检测到Apache Web Server，建议检查版本并应用最新补丁",
                "cvss_score": 5.0,
                "recommendation": "更新到最新版本"
            })

        return vulnerabilities

    async def _detect_configuration_issues(self, target: str, scan_results: dict) -> List[dict]:
        """检测配置问题"""
        issues = []

        # 检查开放的危险端口
        dangerous_ports = [23, 21, 139, 445, 3389]

        for port_info in scan_results.get("open_ports", []):
            if port_info["port"] in dangerous_ports:
                issues.append({
                    "type": "configuration_issue",
                    "port": port_info["port"],
                    "severity": "high",
                    "title": f"危险端口开放: {port_info['port']}",
                    "description": f"端口 {port_info['port']} ({port_info.get('service', 'unknown')}) 对外开放",
                    "cvss_score": 7.5,
                    "recommendation": "如非必要，建议关闭此端口或限制访问"
                })

        return issues

    async def full_scan(self, target: str, options: dict) -> dict:
        """
        完整扫描

        Args:
            target: 目标地址
            options: 扫描选项

        Returns:
            扫描结果
        """
        logger.info(f"执行完整扫描: {target}")

        # 执行所有类型的扫描
        results = await self.vulnerability_scan(target, options)

        # 添加CVSS评分
        results["vulnerabilities"] = [
            self._calculate_cvss_score(vuln)
            for vuln in results.get("vulnerabilities", [])
        ]

        # 按严重程度排序
        results["vulnerabilities"].sort(
            key=lambda x: x.get("cvss_score", 0),
            reverse=True
        )

        return results

    def _calculate_cvss_score(self, vulnerability: dict) -> dict:
        """计算CVSS评分"""
        # 简化的CVSS v3.1评分计算
        severity_scores = {
            "critical": 9.0,
            "high": 7.5,
            "medium": 5.0,
            "low": 2.5,
            "info": 0.0
        }

        if "cvss_score" not in vulnerability:
            severity = vulnerability.get("severity", "low")
            vulnerability["cvss_score"] = severity_scores.get(severity, 5.0)

        # 添加严重程度等级
        score = vulnerability["cvss_score"]
        if score >= 9.0:
            vulnerability["severity"] = "critical"
        elif score >= 7.0:
            vulnerability["severity"] = "high"
        elif score >= 4.0:
            vulnerability["severity"] = "medium"
        elif score > 0.0:
            vulnerability["severity"] = "low"
        else:
            vulnerability["severity"] = "info"

        return vulnerability

    async def get_scan_status(self, scan_id: str) -> Optional[dict]:
        """获取扫描状态"""
        return await self.db_manager.get_scan_task(scan_id)

    async def get_scan_results(self, scan_id: str) -> Optional[dict]:
        """获取扫描结果"""
        return await self.db_manager.get_scan_results(scan_id)

    async def save_scan_results(self, scan_id: str, results: dict):
        """保存扫描结果"""
        await self.db_manager.save_scan_results(scan_id, results)

    async def update_scan_status(self, scan_id: str, status: str, error: str = None):
        """更新扫描状态"""
        update_data = {
            "status": status,
            "updated_at": datetime.utcnow().isoformat()
        }

        if error:
            update_data["error"] = error

        await self.db_manager.update_scan_task(scan_id, update_data)

        if scan_id in self.active_scans:
            self.active_scans[scan_id].update(update_data)
