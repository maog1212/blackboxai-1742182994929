"""
漏洞数据库模块
"""
import asyncio
import aiohttp
import logging
from datetime import datetime
from typing import List, Dict, Optional
import os

logger = logging.getLogger(__name__)


class VulnerabilityDatabase:
    """漏洞数据库管理类"""

    def __init__(self):
        self.cve_api_key = os.getenv("CVE_API_KEY", "")
        self.nvd_api_key = os.getenv("NVD_API_KEY", "")
        self.cve_base_url = "https://cve.circl.lu/api"
        self.nvd_base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.last_update = None
        self.vulnerability_cache = {}

    async def initialize(self):
        """初始化漏洞数据库"""
        logger.info("初始化漏洞数据库...")

        # 可以在这里加载本地漏洞数据库
        # 或者从远程源同步最新数据

        logger.info("漏洞数据库初始化完成")

    async def update(self):
        """更新漏洞数据库"""
        logger.info("开始更新漏洞数据库...")

        try:
            # 更新CVE数据
            await self._update_cve_data()

            # 更新NVD数据
            await self._update_nvd_data()

            # 更新安全公告
            await self._update_security_advisories()

            self.last_update = datetime.utcnow()

            logger.info("漏洞数据库更新完成")

        except Exception as e:
            logger.error(f"更新漏洞数据库失败: {str(e)}")
            raise

    async def _update_cve_data(self):
        """更新CVE数据"""
        logger.info("更新CVE数据...")

        try:
            async with aiohttp.ClientSession() as session:
                # 获取最近的CVE
                url = f"{self.cve_base_url}/last"

                async with session.get(url) as response:
                    if response.status == 200:
                        data = await response.json()
                        logger.info(f"获取到 {len(data)} 条CVE数据")

                        # 缓存CVE数据
                        for cve in data:
                            cve_id = cve.get('id')
                            if cve_id:
                                self.vulnerability_cache[cve_id] = cve

                    else:
                        logger.warning(f"CVE API返回状态码: {response.status}")

        except Exception as e:
            logger.error(f"更新CVE数据失败: {str(e)}")

    async def _update_nvd_data(self):
        """更新NVD数据"""
        logger.info("更新NVD数据...")

        if not self.nvd_api_key:
            logger.warning("未配置NVD API密钥，跳过NVD数据更新")
            return

        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "apiKey": self.nvd_api_key
                }

                # 获取最近修改的CVE
                async with session.get(
                    self.nvd_base_url,
                    headers=headers,
                    params={"resultsPerPage": 100}
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        vulnerabilities = data.get('vulnerabilities', [])

                        logger.info(f"获取到 {len(vulnerabilities)} 条NVD数据")

                        # 处理并缓存数据
                        for vuln_data in vulnerabilities:
                            cve = vuln_data.get('cve', {})
                            cve_id = cve.get('id')

                            if cve_id:
                                self.vulnerability_cache[cve_id] = {
                                    "id": cve_id,
                                    "description": self._extract_description(cve),
                                    "cvss": self._extract_cvss(cve),
                                    "references": self._extract_references(cve),
                                    "published": cve.get('published'),
                                    "modified": cve.get('lastModified')
                                }

                    else:
                        logger.warning(f"NVD API返回状态码: {response.status}")

        except Exception as e:
            logger.error(f"更新NVD数据失败: {str(e)}")

    def _extract_description(self, cve: dict) -> str:
        """提取CVE描述"""
        descriptions = cve.get('descriptions', [])
        for desc in descriptions:
            if desc.get('lang') == 'en':
                return desc.get('value', '')
        return descriptions[0].get('value', '') if descriptions else ''

    def _extract_cvss(self, cve: dict) -> Dict:
        """提取CVSS评分"""
        metrics = cve.get('metrics', {})

        # 优先使用CVSS v3.1
        cvss_v31 = metrics.get('cvssMetricV31', [])
        if cvss_v31:
            cvss_data = cvss_v31[0].get('cvssData', {})
            return {
                "version": "3.1",
                "score": cvss_data.get('baseScore', 0),
                "severity": cvss_data.get('baseSeverity', 'UNKNOWN'),
                "vector": cvss_data.get('vectorString', '')
            }

        # 回退到CVSS v3.0
        cvss_v3 = metrics.get('cvssMetricV30', [])
        if cvss_v3:
            cvss_data = cvss_v3[0].get('cvssData', {})
            return {
                "version": "3.0",
                "score": cvss_data.get('baseScore', 0),
                "severity": cvss_data.get('baseSeverity', 'UNKNOWN'),
                "vector": cvss_data.get('vectorString', '')
            }

        # 回退到CVSS v2
        cvss_v2 = metrics.get('cvssMetricV2', [])
        if cvss_v2:
            cvss_data = cvss_v2[0].get('cvssData', {})
            return {
                "version": "2.0",
                "score": cvss_data.get('baseScore', 0),
                "severity": self._cvss2_to_severity(cvss_data.get('baseScore', 0)),
                "vector": cvss_data.get('vectorString', '')
            }

        return {"version": "unknown", "score": 0, "severity": "UNKNOWN"}

    def _cvss2_to_severity(self, score: float) -> str:
        """将CVSS v2分数转换为严重程度"""
        if score >= 7.0:
            return "HIGH"
        elif score >= 4.0:
            return "MEDIUM"
        else:
            return "LOW"

    def _extract_references(self, cve: dict) -> List[str]:
        """提取参考链接"""
        references = cve.get('references', [])
        return [ref.get('url', '') for ref in references]

    async def _update_security_advisories(self):
        """更新安全公告"""
        logger.info("更新安全公告...")

        # 这里可以添加各个厂商的安全公告源
        # 例如：Microsoft、RedHat、Ubuntu等

        logger.info("安全公告更新完成")

    async def search_vulnerability(self, product: str, version: str) -> List[Dict]:
        """
        搜索漏洞

        Args:
            product: 产品名称
            version: 版本号

        Returns:
            漏洞列表
        """
        logger.info(f"搜索漏洞: {product} {version}")

        vulnerabilities = []

        try:
            async with aiohttp.ClientSession() as session:
                # 使用CVE API搜索
                url = f"{self.cve_base_url}/search/{product}/{version}"

                async with session.get(url) as response:
                    if response.status == 200:
                        data = await response.json()
                        vulnerabilities = data

        except Exception as e:
            logger.error(f"搜索漏洞失败: {str(e)}")

        return vulnerabilities

    async def get_vulnerability_by_id(self, cve_id: str) -> Optional[Dict]:
        """
        根据CVE ID获取漏洞信息

        Args:
            cve_id: CVE ID

        Returns:
            漏洞信息
        """
        # 先检查缓存
        if cve_id in self.vulnerability_cache:
            return self.vulnerability_cache[cve_id]

        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.cve_base_url}/cve/{cve_id}"

                async with session.get(url) as response:
                    if response.status == 200:
                        data = await response.json()

                        # 缓存结果
                        self.vulnerability_cache[cve_id] = data

                        return data

        except Exception as e:
            logger.error(f"获取CVE信息失败: {str(e)}")

        return None

    async def get_statistics(self) -> Dict:
        """
        获取漏洞数据库统计信息

        Returns:
            统计信息
        """
        stats = {
            "total_vulnerabilities": len(self.vulnerability_cache),
            "last_update": self.last_update.isoformat() if self.last_update else None,
            "by_severity": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            }
        }

        # 统计各严重程度的漏洞数量
        for vuln in self.vulnerability_cache.values():
            cvss = vuln.get('cvss', {})
            severity = cvss.get('severity', 'UNKNOWN').lower()

            if severity in stats["by_severity"]:
                stats["by_severity"][severity] += 1

        return stats
