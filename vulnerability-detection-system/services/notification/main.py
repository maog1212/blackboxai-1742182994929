"""
通知服务
实现邮件、Slack、Webhook通知和报告生成
"""
import os
import asyncio
from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from prometheus_client import Counter, generate_latest
from fastapi.responses import Response
from pydantic import BaseModel, EmailStr
from typing import List, Optional, Dict
import logging
import aiohttp
import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
import json

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Prometheus指标
NOTIFICATION_COUNTER = Counter('notifications_sent_total', 'Total notifications sent', ['type', 'status'])


class NotificationRequest(BaseModel):
    """通知请求模型"""
    type: str  # email, slack, webhook
    recipients: List[str]
    subject: str
    message: str
    severity: Optional[str] = "medium"
    data: Optional[Dict] = None


class ReportRequest(BaseModel):
    """报告请求模型"""
    report_type: str  # vulnerability, compliance, trend
    format: str  # pdf, html, json
    start_date: Optional[str] = None
    end_date: Optional[str] = None
    compliance_standard: Optional[str] = None


class EmailNotifier:
    """邮件通知器"""

    def __init__(self):
        self.smtp_host = os.getenv("SMTP_HOST", "")
        self.smtp_port = int(os.getenv("SMTP_PORT", 587))
        self.smtp_username = os.getenv("SMTP_USERNAME", "")
        self.smtp_password = os.getenv("SMTP_PASSWORD", "")
        self.smtp_from = os.getenv("SMTP_FROM", "")
        self.enabled = os.getenv("EMAIL_ENABLED", "true").lower() == "true"

    async def send_email(self, to: List[str], subject: str, body: str, html: bool = False):
        """发送邮件"""
        if not self.enabled:
            logger.info("邮件通知已禁用")
            return {"status": "disabled"}

        try:
            message = MIMEMultipart("alternative")
            message["Subject"] = subject
            message["From"] = self.smtp_from
            message["To"] = ", ".join(to)

            if html:
                part = MIMEText(body, "html")
            else:
                part = MIMEText(body, "plain")

            message.attach(part)

            await aiosmtplib.send(
                message,
                hostname=self.smtp_host,
                port=self.smtp_port,
                username=self.smtp_username,
                password=self.smtp_password,
                start_tls=True
            )

            logger.info(f"邮件已发送至: {', '.join(to)}")
            NOTIFICATION_COUNTER.labels(type='email', status='success').inc()

            return {"status": "sent", "recipients": to}

        except Exception as e:
            logger.error(f"发送邮件失败: {str(e)}")
            NOTIFICATION_COUNTER.labels(type='email', status='failed').inc()
            raise


class SlackNotifier:
    """Slack通知器"""

    def __init__(self):
        self.webhook_url = os.getenv("SLACK_WEBHOOK", "")
        self.channel = os.getenv("SLACK_CHANNEL", "#security-alerts")
        self.enabled = bool(self.webhook_url)

    async def send_message(self, message: str, severity: str = "medium"):
        """发送Slack消息"""
        if not self.enabled:
            logger.info("Slack通知已禁用")
            return {"status": "disabled"}

        try:
            # 根据严重程度选择颜色
            color_map = {
                "critical": "#FF0000",
                "high": "#FF6600",
                "medium": "#FFCC00",
                "low": "#00CC00",
                "info": "#0099FF"
            }

            color = color_map.get(severity, "#CCCCCC")

            payload = {
                "channel": self.channel,
                "attachments": [
                    {
                        "color": color,
                        "title": f"安全告警 - {severity.upper()}",
                        "text": message,
                        "footer": "漏洞检测系统",
                        "ts": int(datetime.utcnow().timestamp())
                    }
                ]
            }

            async with aiohttp.ClientSession() as session:
                async with session.post(self.webhook_url, json=payload) as response:
                    if response.status == 200:
                        logger.info("Slack消息已发送")
                        NOTIFICATION_COUNTER.labels(type='slack', status='success').inc()
                        return {"status": "sent"}
                    else:
                        error_text = await response.text()
                        logger.error(f"发送Slack消息失败: {error_text}")
                        NOTIFICATION_COUNTER.labels(type='slack', status='failed').inc()
                        return {"status": "failed", "error": error_text}

        except Exception as e:
            logger.error(f"发送Slack消息失败: {str(e)}")
            NOTIFICATION_COUNTER.labels(type='slack', status='failed').inc()
            raise


class WebhookNotifier:
    """Webhook通知器"""

    def __init__(self):
        self.webhook_url = os.getenv("CUSTOM_WEBHOOK_URL", "")
        self.enabled = os.getenv("WEBHOOK_ENABLED", "false").lower() == "true"

    async def send_webhook(self, data: dict):
        """发送Webhook通知"""
        if not self.enabled or not self.webhook_url:
            logger.info("Webhook通知已禁用")
            return {"status": "disabled"}

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(self.webhook_url, json=data) as response:
                    if response.status in [200, 201, 204]:
                        logger.info("Webhook通知已发送")
                        NOTIFICATION_COUNTER.labels(type='webhook', status='success').inc()
                        return {"status": "sent"}
                    else:
                        error_text = await response.text()
                        logger.error(f"发送Webhook失败: {error_text}")
                        NOTIFICATION_COUNTER.labels(type='webhook', status='failed').inc()
                        return {"status": "failed", "error": error_text}

        except Exception as e:
            logger.error(f"发送Webhook失败: {str(e)}")
            NOTIFICATION_COUNTER.labels(type='webhook', status='failed').inc()
            raise


class ReportGenerator:
    """报告生成器"""

    async def generate_report(self, request: ReportRequest) -> dict:
        """生成报告"""
        logger.info(f"生成报告: {request.report_type}")

        if request.report_type == "vulnerability":
            report = await self._generate_vulnerability_report(request)
        elif request.report_type == "compliance":
            report = await self._generate_compliance_report(request)
        elif request.report_type == "trend":
            report = await self._generate_trend_report(request)
        else:
            raise ValueError(f"不支持的报告类型: {request.report_type}")

        return report

    async def _generate_vulnerability_report(self, request: ReportRequest) -> dict:
        """生成漏洞报告"""
        # 这里应该从数据库查询漏洞数据
        # 简化示例

        report_data = {
            "title": "漏洞扫描报告",
            "generated_at": datetime.utcnow().isoformat(),
            "period": {
                "start": request.start_date,
                "end": request.end_date
            },
            "summary": {
                "total_vulnerabilities": 156,
                "critical": 12,
                "high": 34,
                "medium": 67,
                "low": 43
            },
            "top_vulnerabilities": [
                {
                    "cve_id": "CVE-2023-12345",
                    "severity": "critical",
                    "affected_systems": 5,
                    "status": "open"
                }
            ],
            "recommendations": [
                "立即修复所有Critical级别漏洞",
                "在7天内修复High级别漏洞",
                "定期更新系统补丁"
            ]
        }

        if request.format == "json":
            return report_data
        elif request.format == "html":
            html_report = self._format_html_report(report_data)
            return {"format": "html", "content": html_report}
        else:
            return report_data

    async def _generate_compliance_report(self, request: ReportRequest) -> dict:
        """生成合规报告"""
        standard = request.compliance_standard or "ISO27001"

        report_data = {
            "title": f"{standard} 合规报告",
            "generated_at": datetime.utcnow().isoformat(),
            "standard": standard,
            "compliance_score": 85.5,
            "controls": [
                {
                    "control_id": "A.12.6.1",
                    "name": "技术漏洞管理",
                    "status": "compliant",
                    "score": 90
                },
                {
                    "control_id": "A.12.2.1",
                    "name": "控制恶意代码",
                    "status": "partial",
                    "score": 75
                }
            ],
            "gaps": [
                "需要加强日志监控",
                "补丁管理流程需要改进"
            ]
        }

        return report_data

    async def _generate_trend_report(self, request: ReportRequest) -> dict:
        """生成趋势分析报告"""
        report_data = {
            "title": "安全趋势分析报告",
            "generated_at": datetime.utcnow().isoformat(),
            "period": {
                "start": request.start_date,
                "end": request.end_date
            },
            "trends": {
                "vulnerability_discovery": [
                    {"date": "2023-10-01", "count": 45},
                    {"date": "2023-10-08", "count": 52},
                    {"date": "2023-10-15", "count": 38}
                ],
                "remediation_rate": 78.5,
                "mean_time_to_remediate": 5.2
            },
            "insights": [
                "漏洞发现数量呈下降趋势",
                "修复速度有所提升",
                "Critical漏洞平均修复时间为2.5天"
            ]
        }

        return report_data

    def _format_html_report(self, data: dict) -> str:
        """格式化HTML报告"""
        html = f"""
        <html>
        <head>
            <title>{data['title']}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h1 {{ color: #333; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #4CAF50; color: white; }}
                .critical {{ color: #d32f2f; }}
                .high {{ color: #f57c00; }}
                .medium {{ color: #fbc02d; }}
                .low {{ color: #388e3c; }}
            </style>
        </head>
        <body>
            <h1>{data['title']}</h1>
            <p>生成时间: {data['generated_at']}</p>
            <h2>摘要</h2>
            <table>
                <tr>
                    <th>严重程度</th>
                    <th>数量</th>
                </tr>
                <tr>
                    <td class="critical">Critical</td>
                    <td>{data['summary']['critical']}</td>
                </tr>
                <tr>
                    <td class="high">High</td>
                    <td>{data['summary']['high']}</td>
                </tr>
                <tr>
                    <td class="medium">Medium</td>
                    <td>{data['summary']['medium']}</td>
                </tr>
                <tr>
                    <td class="low">Low</td>
                    <td>{data['summary']['low']}</td>
                </tr>
            </table>
        </body>
        </html>
        """
        return html


@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    logger.info("启动通知服务...")
    yield
    logger.info("关闭通知服务...")


app = FastAPI(
    title="Notification Service",
    description="通知和报告服务",
    version="1.0.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

email_notifier = EmailNotifier()
slack_notifier = SlackNotifier()
webhook_notifier = WebhookNotifier()
report_generator = ReportGenerator()


@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "healthy", "service": "notification", "version": "1.0.0"}


@app.get("/metrics")
async def metrics():
    """Prometheus指标"""
    return Response(content=generate_latest(), media_type="text/plain")


@app.post("/notify")
async def send_notification(request: NotificationRequest):
    """发送通知"""
    try:
        results = []

        if request.type == "email":
            result = await email_notifier.send_email(
                request.recipients,
                request.subject,
                request.message
            )
            results.append(result)

        elif request.type == "slack":
            result = await slack_notifier.send_message(
                request.message,
                request.severity
            )
            results.append(result)

        elif request.type == "webhook":
            data = {
                "subject": request.subject,
                "message": request.message,
                "severity": request.severity,
                "data": request.data,
                "timestamp": datetime.utcnow().isoformat()
            }
            result = await webhook_notifier.send_webhook(data)
            results.append(result)

        elif request.type == "all":
            # 发送所有类型的通知
            email_result = await email_notifier.send_email(
                request.recipients,
                request.subject,
                request.message
            )
            slack_result = await slack_notifier.send_message(
                request.message,
                request.severity
            )
            results.extend([email_result, slack_result])

        else:
            raise ValueError(f"不支持的通知类型: {request.type}")

        return {"status": "success", "results": results}

    except Exception as e:
        logger.error(f"发送通知失败: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/report")
async def generate_report(request: ReportRequest):
    """生成报告"""
    try:
        report = await report_generator.generate_report(request)
        return report
    except Exception as e:
        logger.error(f"生成报告失败: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    import uvicorn

    port = int(os.getenv("NOTIFICATION_PORT", 8084))
    host = os.getenv("NOTIFICATION_HOST", "0.0.0.0")

    uvicorn.run("main:app", host=host, port=port, reload=True, log_level="info")
