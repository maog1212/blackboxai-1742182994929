"""
检测引擎服务
实现实时监控、文件完整性检查、日志异常检测
"""
import os
import asyncio
from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from prometheus_client import Counter, Histogram, generate_latest
from fastapi.responses import Response
import logging
import yaml

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Prometheus指标
DETECTION_COUNTER = Counter('detections_total', 'Total detections', ['type'])
DETECTION_DURATION = Histogram('detection_duration_seconds', 'Detection duration')


class FileIntegrityMonitor:
    """文件完整性监控"""

    def __init__(self):
        self.watched_files = {}
        self.alerts = []

    async def check_integrity(self, file_path: str) -> dict:
        """检查文件完整性"""
        import hashlib

        try:
            with open(file_path, 'rb') as f:
                file_hash = hashlib.sha256(f.read()).hexdigest()

            if file_path in self.watched_files:
                if self.watched_files[file_path] != file_hash:
                    alert = {
                        "type": "file_modified",
                        "file": file_path,
                        "old_hash": self.watched_files[file_path],
                        "new_hash": file_hash,
                        "severity": "high"
                    }
                    self.alerts.append(alert)
                    DETECTION_COUNTER.labels(type='file_modification').inc()
                    return alert

            self.watched_files[file_path] = file_hash
            return {"status": "ok"}

        except Exception as e:
            logger.error(f"文件完整性检查失败: {str(e)}")
            return {"status": "error", "message": str(e)}


class LogAnomalyDetector:
    """日志异常检测"""

    def __init__(self):
        self.patterns = {
            "sql_injection": r"(union.*select|select.*from|insert.*into|delete.*from)",
            "xss": r"(<script|javascript:|onerror=|onload=)",
            "path_traversal": r"(\.\./|\.\.\\)",
            "command_injection": r"(;|\||&|\$\(|\`)",
            "authentication_failure": r"(failed login|authentication failed|invalid password)",
        }

    async def analyze_log(self, log_entry: str) -> dict:
        """分析日志条目"""
        import re

        detections = []

        for pattern_name, pattern in self.patterns.items():
            if re.search(pattern, log_entry, re.IGNORECASE):
                detection = {
                    "type": pattern_name,
                    "log": log_entry,
                    "severity": self._get_severity(pattern_name)
                }
                detections.append(detection)
                DETECTION_COUNTER.labels(type=pattern_name).inc()

        return {
            "detections": detections,
            "count": len(detections)
        }

    def _get_severity(self, pattern_name: str) -> str:
        """获取严重程度"""
        high_severity = ["sql_injection", "command_injection"]
        medium_severity = ["xss", "path_traversal"]

        if pattern_name in high_severity:
            return "high"
        elif pattern_name in medium_severity:
            return "medium"
        else:
            return "low"


class RuleEngine:
    """自定义规则引擎"""

    def __init__(self, rules_path: str):
        self.rules_path = rules_path
        self.rules = {}
        self.load_rules()

    def load_rules(self):
        """加载检测规则"""
        import os

        if not os.path.exists(self.rules_path):
            logger.warning(f"规则目录不存在: {self.rules_path}")
            return

        for filename in os.listdir(self.rules_path):
            if filename.endswith(('.yaml', '.yml')):
                rule_file = os.path.join(self.rules_path, filename)

                try:
                    with open(rule_file, 'r') as f:
                        rule_data = yaml.safe_load(f)
                        rule_id = rule_data.get('id', filename)
                        self.rules[rule_id] = rule_data
                        logger.info(f"加载规则: {rule_id}")

                except Exception as e:
                    logger.error(f"加载规则文件失败 {filename}: {str(e)}")

    def evaluate_rule(self, rule_id: str, data: dict) -> bool:
        """评估规则"""
        if rule_id not in self.rules:
            return False

        rule = self.rules[rule_id]
        conditions = rule.get('conditions', [])

        # 简化的规则评估逻辑
        for condition in conditions:
            field = condition.get('field')
            operator = condition.get('operator')
            value = condition.get('value')

            if field in data:
                if operator == 'equals' and data[field] == value:
                    return True
                elif operator == 'contains' and value in str(data[field]):
                    return True
                elif operator == 'greater_than' and data[field] > value:
                    return True

        return False


@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    logger.info("启动检测引擎服务...")
    yield
    logger.info("关闭检测引擎服务...")


app = FastAPI(
    title="Detection Engine Service",
    description="自动化检测引擎服务",
    version="1.0.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 初始化组件
file_monitor = FileIntegrityMonitor()
log_detector = LogAnomalyDetector()
rule_engine = RuleEngine(os.getenv("DETECTION_RULES_PATH", "/app/rules"))


@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "healthy", "service": "detection-engine", "version": "1.0.0"}


@app.get("/metrics")
async def metrics():
    """Prometheus指标"""
    return Response(content=generate_latest(), media_type="text/plain")


@app.post("/detect/file-integrity")
async def check_file_integrity(file_path: str):
    """检查文件完整性"""
    try:
        result = await file_monitor.check_integrity(file_path)
        return result
    except Exception as e:
        logger.error(f"文件完整性检查失败: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/detect/log-anomaly")
async def detect_log_anomaly(log_entry: str):
    """检测日志异常"""
    try:
        result = await log_detector.analyze_log(log_entry)
        return result
    except Exception as e:
        logger.error(f"日志异常检测失败: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/detect/custom-rule")
async def evaluate_custom_rule(rule_id: str, data: dict):
    """评估自定义规则"""
    try:
        result = rule_engine.evaluate_rule(rule_id, data)
        return {"rule_id": rule_id, "matched": result}
    except Exception as e:
        logger.error(f"规则评估失败: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/rules")
async def list_rules():
    """列出所有规则"""
    return {"rules": list(rule_engine.rules.keys()), "count": len(rule_engine.rules)}


@app.post("/rules/reload")
async def reload_rules():
    """重新加载规则"""
    try:
        rule_engine.load_rules()
        return {"status": "success", "message": "规则已重新加载"}
    except Exception as e:
        logger.error(f"重新加载规则失败: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/alerts")
async def get_alerts():
    """获取告警"""
    return {"alerts": file_monitor.alerts, "count": len(file_monitor.alerts)}


if __name__ == "__main__":
    import uvicorn

    port = int(os.getenv("DETECTION_PORT", 8082))
    host = os.getenv("DETECTION_HOST", "0.0.0.0")

    uvicorn.run("main:app", host=host, port=port, reload=True, log_level="info")
