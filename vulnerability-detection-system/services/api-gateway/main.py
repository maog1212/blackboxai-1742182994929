"""
API Gateway服务
统一入口、认证授权、请求路由
"""
import os
import asyncio
from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, Depends, Header, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from prometheus_client import Counter, Histogram, generate_latest
from fastapi.responses import Response
from pydantic import BaseModel
import logging
import aiohttp
import jwt
from datetime import datetime, timedelta
from typing import Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Prometheus指标
REQUEST_COUNTER = Counter('api_requests_total', 'Total API requests', ['method', 'endpoint', 'status'])
REQUEST_DURATION = Histogram('api_request_duration_seconds', 'Request duration')

# 服务地址配置
SERVICES = {
    "scanner": os.getenv("SCANNER_URL", "http://scanner:8081"),
    "detection": os.getenv("DETECTION_URL", "http://detection-engine:8082"),
    "response": os.getenv("RESPONSE_URL", "http://response:8083"),
    "notification": os.getenv("NOTIFICATION_URL", "http://notification:8084")
}

# JWT配置
JWT_SECRET = os.getenv("JWT_SECRET", "your-secret-key-change-this")
JWT_ALGORITHM = "HS256"
JWT_EXPIRATION = int(os.getenv("JWT_EXPIRATION_HOURS", 24))

security = HTTPBearer()


class TokenData(BaseModel):
    """Token数据模型"""
    username: str
    exp: datetime


class LoginRequest(BaseModel):
    """登录请求模型"""
    username: str
    password: str


def create_access_token(username: str) -> str:
    """创建访问令牌"""
    expire = datetime.utcnow() + timedelta(hours=JWT_EXPIRATION)
    to_encode = {"sub": username, "exp": expire}
    encoded_jwt = jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)
    return encoded_jwt


def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    """验证令牌"""
    try:
        token = credentials.credentials
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        username: str = payload.get("sub")

        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials"
            )

        return username

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired"
        )
    except jwt.JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )


async def proxy_request(service: str, path: str, method: str = "GET", data: dict = None):
    """代理请求到后端服务"""
    if service not in SERVICES:
        raise HTTPException(status_code=404, detail=f"Service {service} not found")

    url = f"{SERVICES[service]}{path}"

    try:
        async with aiohttp.ClientSession() as session:
            if method == "GET":
                async with session.get(url) as response:
                    return await response.json()
            elif method == "POST":
                async with session.post(url, json=data) as response:
                    return await response.json()
            elif method == "PUT":
                async with session.put(url, json=data) as response:
                    return await response.json()
            elif method == "DELETE":
                async with session.delete(url) as response:
                    return await response.json()

    except aiohttp.ClientError as e:
        logger.error(f"Proxy request failed: {str(e)}")
        raise HTTPException(status_code=502, detail="Bad gateway")


@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    logger.info("启动API Gateway...")
    yield
    logger.info("关闭API Gateway...")


app = FastAPI(
    title="Vulnerability Detection System API",
    description="漏洞检测系统统一API",
    version="1.0.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "healthy", "service": "api-gateway", "version": "1.0.0"}


@app.get("/metrics")
async def metrics():
    """Prometheus指标"""
    return Response(content=generate_latest(), media_type="text/plain")


@app.post("/auth/login")
async def login(request: LoginRequest):
    """用户登录"""
    # 简化的认证逻辑，实际应该查询数据库
    if request.username == "admin" and request.password == "admin":
        token = create_access_token(request.username)
        return {"access_token": token, "token_type": "bearer"}

    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Incorrect username or password"
    )


@app.get("/auth/verify")
async def verify(username: str = Depends(verify_token)):
    """验证令牌"""
    return {"username": username, "valid": True}


# Scanner Service路由
@app.post("/api/v1/scan")
async def start_scan(data: dict, username: str = Depends(verify_token)):
    """启动扫描"""
    REQUEST_COUNTER.labels(method='POST', endpoint='/scan', status='success').inc()
    return await proxy_request("scanner", "/scan", "POST", data)


@app.get("/api/v1/scan/{scan_id}")
async def get_scan_status(scan_id: str, username: str = Depends(verify_token)):
    """获取扫描状态"""
    return await proxy_request("scanner", f"/scan/{scan_id}", "GET")


@app.get("/api/v1/scan/{scan_id}/results")
async def get_scan_results(scan_id: str, username: str = Depends(verify_token)):
    """获取扫描结果"""
    return await proxy_request("scanner", f"/scan/{scan_id}/results", "GET")


@app.post("/api/v1/discover-assets")
async def discover_assets(data: dict, username: str = Depends(verify_token)):
    """资产发现"""
    return await proxy_request("scanner", "/discover-assets", "POST", data)


# Detection Engine路由
@app.post("/api/v1/detect/file-integrity")
async def check_file_integrity(data: dict, username: str = Depends(verify_token)):
    """文件完整性检查"""
    return await proxy_request("detection", "/detect/file-integrity", "POST", data)


@app.post("/api/v1/detect/log-anomaly")
async def detect_log_anomaly(data: dict, username: str = Depends(verify_token)):
    """日志异常检测"""
    return await proxy_request("detection", "/detect/log-anomaly", "POST", data)


@app.get("/api/v1/rules")
async def list_detection_rules(username: str = Depends(verify_token)):
    """列出检测规则"""
    return await proxy_request("detection", "/rules", "GET")


# Response Service路由
@app.post("/api/v1/remediation/plan")
async def create_remediation_plan(data: dict, username: str = Depends(verify_token)):
    """创建修复计划"""
    return await proxy_request("response", "/remediation/plan", "POST", data)


@app.post("/api/v1/remediation/execute")
async def execute_remediation(data: dict, username: str = Depends(verify_token)):
    """执行修复"""
    return await proxy_request("response", "/remediation/execute", "POST", data)


@app.post("/api/v1/remediation/verify")
async def verify_remediation(data: dict, username: str = Depends(verify_token)):
    """验证修复"""
    return await proxy_request("response", "/remediation/verify", "POST", data)


# Notification Service路由
@app.post("/api/v1/notify")
async def send_notification(data: dict, username: str = Depends(verify_token)):
    """发送通知"""
    return await proxy_request("notification", "/notify", "POST", data)


@app.post("/api/v1/report")
async def generate_report(data: dict, username: str = Depends(verify_token)):
    """生成报告"""
    return await proxy_request("notification", "/report", "POST", data)


@app.get("/api/v1/services/status")
async def get_services_status(username: str = Depends(verify_token)):
    """获取所有服务状态"""
    statuses = {}

    for service_name, service_url in SERVICES.items():
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{service_url}/health", timeout=aiohttp.ClientTimeout(total=5)) as response:
                    if response.status == 200:
                        data = await response.json()
                        statuses[service_name] = data
                    else:
                        statuses[service_name] = {"status": "unhealthy"}
        except Exception as e:
            statuses[service_name] = {"status": "unreachable", "error": str(e)}

    return {"services": statuses}


if __name__ == "__main__":
    import uvicorn

    port = int(os.getenv("API_GATEWAY_PORT", 8080))
    host = os.getenv("API_GATEWAY_HOST", "0.0.0.0")

    uvicorn.run("main:app", host=host, port=port, reload=True, log_level="info")
